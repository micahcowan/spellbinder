import Data.Char (isSpace, toLower, toUpper)
import Data.List (intercalate, sort)

import Spellbinder.Gestures

-- convenience type to modify String's show
data Label = Label String
instance Show Label where
    show label = unlabel label
unlabel (Label str) = str

type SpellBookEntry' = ([ HandUsage ], Label)

makeModule :: String -> String
makeModule input =
    let entries = parse input
        moduleName = "Spellbinder.SpellBook"
        spellBookName = "spellBook"
        spellTypeName = "Spell"
        entryTypeName = "SpellBookEntry"
        spellNameList = uniq . sort $ map (unlabel . snd) entries

        uniq (a:b:cs) =
            if a == b then uniq (a:cs) else a : uniq (b:cs)
        uniq cs = cs
     in "\
\-- WARNING! This file is generated by Spellbinder.SpellBookParser\n\
\-- from spells.txt.  Edit spells.txt, not this file.\n\
\module " ++ moduleName ++ "\n\
\  (\n\
\    " ++ spellBookName ++ "\n\
\  , " ++ spellTypeName ++ "(..)\n\
\  )\n\
\where\n\
\\n\
\\n\
\import Spellbinder.Gestures\n\
\\n\
\data " ++ spellTypeName ++ " = \n\
\    " ++ intercalate "\n  | " spellNameList ++ "\n\
\  deriving (Show)\n\
\\n\
\type " ++ entryTypeName ++ " = ([ HandUsage ], Spell)\n\
\\n\
\\&" ++ spellBookName ++ " :: [ " ++ entryTypeName ++ " ]\n\
\\&" ++ spellBookName ++ " = \n\
\  [\n\
\    "  ++ intercalate "\n  , " (map show entries) ++ "\n\
\  ]\n"


parse :: String -> [SpellBookEntry']
parse = map parseLine . zip [1..] . lines

parseLine :: (Int, String) -> SpellBookEntry'
parseLine (lnum, line) = 
    let (handSpec, spellName') = span (not . isSpace) line
        spellName = concatMap capitalize . words $ dropWhile isSpace spellName'
        capitalize = zipWith ($) (toUpper : repeat toLower)
    in
        case parseSpellHands handSpec of
            Left bad -> error $
                            "Bad gesture " ++ show bad
                            ++ " in " ++ handSpec ++ ", line " ++ show lnum
            Right hands -> (reverse hands, Label $ spellName ++ "Spell")

main = interact makeModule
